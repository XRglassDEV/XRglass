name: Fix Wallet Scan via HTTPS JSON-RPC (Auto Push)

on:
  workflow_dispatch:

permissions:
  contents: write

jobs:
  patch-wallet-scan:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Git identity
        run: |
          git config user.name "MiaX"
          git config user.email "miasatox@protonmail.com"

      - name: Ensure folders
        shell: bash
        run: |
          mkdir -p app/api/scan/wallet
          mkdir -p lib

      - name: Replace wallet route (use HTTPS JSON-RPC with retries)
        shell: bash
        run: |
          cat > app/api/scan/wallet/route.ts <<'TS'
          // app/api/scan/wallet/route.ts
          export const runtime = "nodejs";
          import { NextResponse } from "next/server";
          import { computeWalletScore } from "../../../../lib/scoring-wallet";

          // Allow override via env: comma-separated list
          const DEFAULT_ENDPOINTS = [
            "https://xrplcluster.com",          // Anycast, JSON-RPC
            "https://s1.ripple.com:51234",      // Ripple public
            "https://rippled.xrpscan.com"       // XRPSCAN relay
          ];

          function getRpcEndpoints(): string[] {
            const env = process.env.XRPL_RPC_ENDPOINTS;
            if (!env) return DEFAULT_ENDPOINTS;
            return env.split(",").map(s => s.trim()).filter(Boolean);
          }

          function isLikelyXRPAddress(addr: string) {
            return typeof addr === "string" && /^r[1-9A-HJ-NP-Za-km-z]{24,35}$/.test(addr);
          }

          async function rpcRequest<T=any>(url: string, body: any, timeoutMs = 5000): Promise<T> {
            const ctrl = new AbortController();
            const t = setTimeout(() => ctrl.abort(), timeoutMs);
            try {
              const res = await fetch(url, {
                method: "POST",
                headers: { "content-type": "application/json" },
                body: JSON.stringify({ jsonrpc: "2.0", id: 1, ...body }),
                signal: ctrl.signal,
              });
              if (!res.ok) throw new Error(`HTTP ${res.status}`);
              const json = await res.json();
              if (json?.error) throw new Error(json.error?.message || "RPC error");
              // xrplcluster returns rippled-style fields without jsonrpc wrapper sometimes; handle both
              return json?.result ?? json;
            } finally {
              clearTimeout(t);
            }
          }

          async function rpcWithFallback<T=any>(body: any, endpoints = getRpcEndpoints()): Promise<T> {
            let lastErr: any = null;
            for (const ep of endpoints) {
              try {
                return await rpcRequest<T>(ep, body);
              } catch (e) {
                lastErr = e;
              }
            }
            throw lastErr || new Error("All RPC endpoints failed");
          }

          export async function GET(req: Request) {
            try {
              const { searchParams } = new URL(req.url);
              const address = (searchParams.get("address") || "").trim();

              if (!isLikelyXRPAddress(address)) {
                return NextResponse.json(
                  { status: "error", message: "Invalid or missing XRP address." },
                  { status: 400 }
                );
              }

              // 1) account_info
              let accountInfo: any = null;
              try {
                accountInfo = await rpcWithFallback({
                  method: "account_info",
                  params: [{ account: address, ledger_index: "validated" }]
                });
              } catch (e: any) {
                // If account not found, rippled returns an error; we handle that downstream as a signal
                accountInfo = null;
              }

              // 2) account_tx (last 20)
              let txs: any[] = [];
              try {
                const resp: any = await rpcWithFallback({
                  method: "account_tx",
                  params: [{
                    account: address,
                    ledger_index_min: -1,
                    ledger_index_max: -1,
                    limit: 20,
                    forward: false
                  }]
                });
                txs = resp?.transactions || resp?.result?.transactions || [];
              } catch (e) {
                // Non-fatal
                txs = [];
              }

              const data = {
                address,
                accountInfo: accountInfo ?? null,
                transactions: txs,
                fetchedAt: new Date().toISOString(),
              };

              const scored = computeWalletScore(data);
              return NextResponse.json(
                { status: "ok", ...scored, raw: { hasAccount: !!accountInfo, txCount: txs.length } },
                { status: 200 }
              );
            } catch (err: any) {
              return NextResponse.json(
                { status: "error", message: err?.message || "Unexpected error" },
                { status: 500 }
              );
            }
          }
          TS

          # scoring-wallet helper if missing
          if [ ! -f "lib/scoring-wallet.ts" ]; then
          cat > lib/scoring-wallet.ts <<'TS'
          // lib/scoring-wallet.ts
          type Severity = "low" | "medium" | "high";
          type Verdict = "green" | "orange" | "red";
          interface Signal { id: string; label: string; severity: Severity; evidence?: string; }

          const dropsToXRP = (v: string|number)=> (Number(v)||0)/1_000_000;
          const toVerdict = (n:number): Verdict => n>=70 ? "red" : n>=35 ? "orange" : "green";

          export function computeWalletScore(data: any) {
            const signals: Signal[] = [];
            let scoreValue = 0;

            const hasAccount = !!data?.accountInfo?.account_data || !!data?.accountInfo?.account; // allow rippled/cluster variants
            if (!hasAccount) {
              scoreValue += 60;
              signals.push({ id:"account_not_found", label:"Account not found / not funded", severity:"high" });
            } else {
              const ad = (data.accountInfo.account_data || data.accountInfo);
              const txs: any[] = Array.isArray(data.transactions) ? data.transactions : [];

              if (txs.length < 3) {
                scoreValue += 10;
                signals.push({ id:"low_activity_history", label:"Very limited activity history", severity:"low" });
              }

              const outgoing = txs
                .map((t:any)=> t.tx || t?.transaction || t) // handle shapes
                .filter((tx:any)=> tx?.TransactionType==="Payment" && tx?.Account===ad.Account);

              const big = outgoing.find((tx:any)=> typeof tx?.Amount==="string" && dropsToXRP(tx.Amount) >= 1000);
              if (big) {
                scoreValue += 20;
                signals.push({ id:"recent_large_outflow", label:"Recent large outgoing XRP payment", severity:"medium", evidence:`hash ${big?.hash??""} ≥1000 XRP` });
              }

              const bal = dropsToXRP(ad.Balance ?? "0");
              if (bal < 5) {
                scoreValue += 10;
                signals.push({ id:"very_low_balance", label:"Very low XRP balance (< 5 XRP)", severity:"low" });
              }

              if ((ad.Flags ?? 0) === 0) {
                scoreValue += 5;
                signals.push({ id:"no_protective_account_flags", label:"No protective account flags set", severity:"low" });
              }
            }

            const score = toVerdict(scoreValue);
            const summary =
              score==="red" ? "High risk — missing account data or strong risky signals."
              : score==="orange" ? "Moderate risk — some warning signals detected."
              : "Low risk — no major red flags in basic checks.";

            return { address: data.address, score, scoreValue, signals, summary, cachedAt: data.fetchedAt };
          }
          TS
          fi

      - name: Commit & push
        shell: bash
        run: |
          git add .
          git commit -m "fix(api): wallet scan via HTTPS JSON-RPC with retries + timeouts" || echo "no changes"
          git push origin main
